#!/usr/bin/env perl
# PODNAME: echelon 'app basis queue' script to add things to queues
# ABSTRACT: add things to queues, using Echelon

=head1 SYNOPSIS

    add a message to queue fred, will be a simple queue, --type=simple is default
    > echelon -q fred "message to tweet"

    # add a message to the work task queue
    > echelon -q work --type=task "process /some/file/path"

    # add to a pubsub queue
    > echelon --queue=notes --type=pubsub "started a program"

    # listen to all pubsub queue messages forever, messages are writen to stdout
    > echelon --queue=notes --type=pubsub --listen

    # take an item from a simple queue
    > echelon -q fred --pop

    # process an item in a task queue, exit status will determin if it is processed
    # the queue message is passed to the exec command in quotes
    # obviously there are security concerns around doing this, clean your inputs!
    > echelon -q work --type=task --exec "/command/to/run"

    # peek at work items in a task queue, --type=task is default for a peek
    > echelon --peek --count=10 -q work

    to get full help use
    > echelon --help

=head1 DESCRIPTION

Add am item to a queue or process an item from a queue

config file is in ~/.echelon

    echelon:
      queue:
        dsn: dbi:SQLite:/tmp/echelon.sqlite
        user:
        password:


The queue entry holds information about the queue database that you want to connect to, this is
obviously a perl DBI style connection

=cut

#
# (c) Kevin Mulholland, moodfarm@cpan.org
# this code is released under the Perl Artistic License

# -----------------------------------------------------------------------------

use 5.10.0 ;
use strict ;
use warnings ;
use POSIX qw(strftime) ;
use App::Basis ;
use App::Basis::Config ;
use DBI ;
use Echelon::Queue ;
use Date::Manip::Date ;
use feature 'say' ;
use Lingua::EN::Inflexion ;

use constant FIVE_DAYS    => 5 * 24 * 3600 ;
use constant PEEK_DEFAULT => 10 ;
use constant EXEC_DEFAULT => 1 ;

# -----------------------------------------------------------------------------

use constant QUEUE_CONFIG => "$ENV{HOME}/.echelon" ;

my @queue_types = qw(task simple pubsub) ;

# -----------------------------------------------------------------------------
# lets do the testing stuff with private variables
{
    my $testing = 0 ;
    sub set_testing
    {
        $testing = 1 ;
    }
    sub is_testing
    {
        $testing ;
    }
}

# -----------------------------------------------------------------------------

my $program = get_program() ;

# URL parsing from https://metacpan.org/pod/URI
my $valid_url = "(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?" ;

# -----------------------------------------------------------------------------
# always create the datetime strings the same way
sub std_datetime
{
    my ($secs) = @_ ;
    $secs ||= time() ;
    return strftime( "%Y-%m-%d %H:%M:%S UTC", gmtime($secs) ) ;
}

# -----------------------------------------------------------------------------
# convert something like a datetime string or an epoch value into a standardised
# datetime string and epoch value

sub parse_datetime
{
    my ($datetime) = @_ ;
    state $date = Date::Manip::Date->new() ;
    my @ret ;

    if ( !$datetime ) {
        return wantarray ? ( undef, undef ) : undef ;
    } elsif ( $datetime =~ /^\d+$/ ) {
        # assume anything less than five days is a time into the future
        $datetime += time() if ( $datetime <= FIVE_DAYS ) ;
        @ret = ( std_datetime($datetime), $datetime ) ;
    } else {
        # so parse will parse in locale time not as UTC
        $date->parse($datetime) ;
        {
            # if we get a warning about converting the date to a day, there
            # must be a problem with parsing the input date string
            local $SIG{__WARN__} = sub {
                die "Invalid date, could not parse" ;
            } ;
            my $day = $date->printf("%a") ;
        }

        my $d2 = $date->printf("%O %Z") ;
        # reparse the date to get it into UTC, best way I could think of :(
        $date->parse($d2) ;

        # secs_since_1970_GMT is epoch
        @ret = ( std_datetime( $date->secs_since_1970_GMT() ), $date->secs_since_1970_GMT() ) ;
    }

    return wantarray ? @ret : $ret[0] ;
}

# -----------------------------------------------------------------------------
# build suitable config

sub create_default_config
{
    my ($cfg) = @_ ;

    $cfg->store() ;
}

# -----------------------------------------------------------------------------
# connect to the queue DB

sub connect_queue
{
    my ( $dsn, $user, $passwd, $qname ) = @_ ;
    my $dbh =
        DBI->connect( $dsn, $user, $passwd, { RaiseError => 1, PrintError => 0, AutoCommit => 1 } )
        or die "Could not connect to DB $dsn" ;

    if ( $dsn =~ /SQLite/i ) {
        $dbh->do("PRAGMA journal_mode = WAL") ;
        $dbh->do("PRAGMA synchronous = NORMAL") ;
    }

    my $queue = Echelon::Queue->new(
        dbh           => $dbh,
        default_queue => $qname,
        debug         => 0,
    ) ;
    return $queue ;
}

# -----------------------------------------------------------------------------
sub stdout_msg
{
    my $obj = shift ;
    my ( $queue, $data ) = @_ ;

    say "$queue:$data->{msg}" ;
}

# -----------------------------------------------------------------------------
# main

my $action ;

my %opt = init_app(
    help_text => "Simple script to queue messages for later action
            use perldoc $program to get the setup for the " . QUEUE_CONFIG . " config file
        if message is '-' input read from STDIN",
    help_cmdline => "message to send",
    options      => {
        'verbose|v' => 'Output useful information',
        'queue|q=s' => { desc => 'queue to add things to', required => 1 },
        'listen|l' =>
            'Listen for pubsub messages on the queue, use count to limit, default no limit',
        'count|c' => { desc => "number of messages to listen to", default => 0 },
        'activates|a=s' =>
            { desc => 'Parsable UTC datetime after which the message should be valid', },
    }
) ;

my $msg = join( ' ', @ARGV ) ;
if ( $opt{test} ) {
    set_verbose(1) ;
    set_testing(1) ;
}

show_usage( "No config file found", 1 ) if ( !-f QUEUE_CONFIG ) ;

# lets have the config named after this program
my $cfg = App::Basis::Config->new(
    filename     => QUEUE_CONFIG,
    die_on_error => 1
) ;

my $q = $cfg->get("queue") ;
msg_exit( "Could not find valid config in " . QUEUE_CONFIG, 2 ) if ( !$q ) ;

$q->{prefix} ||= "/pubsub" ;
$q->{prefix} .= "/" if ( $opt{queue} !~ /^\// ) ;
$opt{queue} = $q->{prefix} . $opt{queue} ;
$opt{queue} =~ s|//|/|g ;

my $echelonq =
    connect_queue( $q->{dsn}, $q->{user}, $q->{password}, $opt{queue} ) ;

if ( !$echelonq ) {
    msg_exit( "Could not connect to queue $q->{dsn}", 2 ) ;
}

if ( $opt{listen} ) {
    $echelonq->subscribe(
        # callback => \&stdout_msg,
        callback => sub {
            my $obj = shift ;
            my ( $queue, $data ) = @_ ;
            say "$queue:$data->{data}->{msg}" ;
        },
        persist => 1
    ) ;
    $echelonq->listen(
        # datetime     => '2018-12-25',
        listen_delay => 1,
        events       => $opt{count},
    ) ;
} else {
    # if we have a message then this should be added to the queue asap
    if ($msg) {
        my ( $activates, $epoch ) = parse_datetime( $opt{activates} ) ;
        my $resp = $echelonq->publish(
            data      => { msg => $msg },
            activates => $activates
        ) ;
    } else {
        msg_exit("Parameters are required, or message queue is empty") ;
    }
}
